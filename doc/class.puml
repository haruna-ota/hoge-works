@startuml

package line {
  class LineNumber {
    - Int

    + "==()"
    + >=()
    + <=()
    + {static} Option[LineNumber] parse(String, Int last)
  }

  class LineRange {
    - LineNumber start
    - LineNumber end

    + Bool contains(LineRange, LineNumber)
    + {static} Option[LineRange] parse(String)
  }

  LineRange -r-> LineNumber

  interface Body {
    + Body map(String -> String)
    + Body sMap(Body -> Seq[Body])
  }

  class NonEmptyBody {
    - String
  }

  class EmptyBody {
  }

  NonEmptyBody -u-|> Body
  EmptyBody -u-|> Body

  class Text {
    - String

    + {static} Option[Text] parse(String)
  }

  Text -d-> Body

  class Line {
    - LineNumber
    - Body body

    + Body mapIf(LineRange, String -> String)
    + Body mapIf(LineNumber, String -> String)
    + Seq[Body] sMapIf(LineRange, Body -> Seq[Body])
    + Seq[Body] sMapIf(LineNumber, Body -> Seq[Body])
    + Seq[Body] sMapIfOr(LineNumber, Body -> Seq[Body], LineRange, Body -> Seq[Body])
    + Option[Body] yank(LineRange)
    + Option[String] display()
  }

  Line -u-> LineNumber
  Line -u-> LineRange
  Line -r-> Body

  class Lines {
    - [Line]

    + {static} Lines sequenceWith([Body])
    + Int $()
    + Lines map(Line -> Body)
    + Lines sMap(Line -> Seq[Body])
    + Seq[Body] yank(LineRange)
    + Seq[String] display()
  }

  Lines -u-> Line
}

package command {
  interface Command {
  }

  interface "ExecutableCommand / ParsableCommand" as ExecutableCommand {
    + Lines execute(Lines)
    + Option[UndoCommand] undo(Lines)
    + {static} Option[Command] dispatch(String, Int last) { ... }
    + {static} Option[Command] parse(String, Int last)
  }

  ExecutableCommand -u-|> Command

  interface UndoCommand {
    + Lines execute(Lines)
  }

  ExecutableCommand -d-> "0..1" UndoCommand

  class Append {
    - LineNumber
    - Text
  }

  class DeletionUndo {
    - LineNumber
  }

  Append --> DeletionUndo
  
  class Delete {
    - LineRange
  }

  class DeleteUndo {
    - LineNumber
    - [Body]
  }

  Delete --> DeleteUndo
  
  class Move {
    - LineRange
    - LineNumber
  }

  class MoveUndo {
    - LineNumber
    - [Text]
  }

  Move --> MoveUndo

  class Copy {
    - LineRange
    - LineNumber
  }

  Copy --> DeletionUndo

  class Substitute {
    - LineRange
    - Text src
    - Text dst
  }

  class ConvertUndo {
    - LineRange
    - [Body]
  }

  Substitute --> ConvertUndo
  
  class Undo {
    // and extends ParsableCommand
  }
  
  class Execute {
    - LineRange
    - Text regex
    - Motions
  }

  Execute --> ConvertUndo

  class Motions {
    - [Motion]

    + String -> String convert()
  }

  enum Motion {
    - Capitalize
    - Period
    + String -> String convert()
  }
  
  Execute -d-> Motions
  Motions -d-> Motion
  
  class Write {
    // and extends ParsableCommand
  }
  
  Append -u-|> ExecutableCommand
  DeletionUndo -u-|> UndoCommand
  Delete -u-|> ExecutableCommand
  DeleteUndo -u-|> UndoCommand
  Move -u-|> ExecutableCommand
  Copy -u-|> ExecutableCommand
  MoveUndo -u-|> UndoCommand
  Substitute -u-|> ExecutableCommand
  Execute -u---|> ExecutableCommand
  ConvertUndo -u-|> UndoCommand
  Undo -u-|> Command
  Write -u-|> Command
  Append -[hidden]r-> Delete
  Delete -[hidden]r-> Move
  Move -[hidden]r-> Substitute
}

Command -u-> Lines

package editor {
  class Editor {
    - Lines
    - Option[UndoCommand] last

    + {static} Editor boot(FilePath)
    + action()
    - display()
    - Command prompt()
  }
}

Editor -d-> Command
Editor -u-> Lines

@enduml